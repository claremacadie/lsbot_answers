// How do you select an element by its ID and change its text content?
document.getElementById('id-name');
// What methods can you use to add or remove classes from an element?
element.className = 'new-class-name';
element.classList.add('new-class-name');
element.classList.remove('new-class-name');
// How do you add an event listener to a button so that when it is clicked, a function runs?
button.addEventListener('click', func)
// What is event delegation and why might you use it?
// Event delegation is a mechanism by which when an action occurs in the DOM, and event object is created and it propagates through the DOM triggering any relevant event listeners attached to DOM nodes that are either the target node (the element on which the action occurred), or for which the target node is an ancestor of. By default, event listeners are set to be triggered on the bubbling phase, but can be set to trigger on the capturing phase. Event listeners on the target are triggered first, then those on the capturing phase and finally those on the bubbling phase. Nodes included in the capturing phase are all those starting from the document node, down to the target node, and nodes included in the bubbling phase are those starting from the target node up to the document node.

// What is a callback function and how is it used in asynchronous code?
// A callback function is a function passed as an argument to the invocation of another function. The callback function can be an asynchronous function. When the asynchronous function is completed, it is added to the task queue. When the call stack is empty, JavaScript takes tasks from the task queue.

// How do Promises help handle asynchronous operations?
// Promise syntax makes asynchronous code more readable, and therefore easier to maintain. Promises are objects that represent the eventual completion of an asynchronous function.

// What does the async/await syntax do, and how does it differ from using .then() with Promises?
// async/await syntax is synctatic sugar for Promises, that makes code look more like synchronous code. It enables, try/catch syntax to be used inside async functions, so that success and error handling code is placed inside the function. await pauses execution of the async function such that JS continues executing synchronouse code. In contrast, .then() and .catch() syntax means that success and error handling code is outside the function.

// How can you use setTimeout or setInterval in JavaScript?
// Both of these create asynchronous code. setTimeout is passed a callback function and a delay (in ms) such that the callback is executed after the delay time has passed. setTinterval is passed a callback function and a time interval, such that the callback is executed repeatedly every time the time interval passes. Both of these functions return an id that can be used to cancel the functions using clearTimout and clearInterval, respectively.

// How do you use fetch to get data from a server and handle the response? AND How would you handle errors when using asynchronous code with fetch? AND How can you take data received from a server and display it dynamically on a web page?
try {
  let response = await fetch('https://someapi.com', {method: 'POST', body: someData});
  if (!response.ok) throw new Error('Response not ok');
  let jsonData = await (response.json);
  let dataObj = Object.fromEntries(jsonData.entries());
  element.textContent = dataObj.name;
} catch(error) {
  console.error(error);
}

